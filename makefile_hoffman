.PHONY: setup_salmon quantify_salmon clean_salmon help create_base_dirs create_project_dirs setup_r_deps preprocess_srr_list

# Makefile for RNA-Seq analysis pipeline using Salmon
# Default number of threads to use
THREADS ?= 4
# Default to paired-end reads unless specified otherwise
ENDTYPE ?= paired
# Default batch size for processing
BATCH_SIZE ?= 6
# Default project name
PROJECT ?= $(shell date +%Y%m%d)

# Directories
SALMON_DIR := salmon_processing
REF_DIR := $(SALMON_DIR)/salmon_ref
FINISHED_DIR := finished_projects
ACCESSIONS_DIR := accession_lists
# Use scratch space for processing
SCRATCH_DIR := /u/scratch/j/jrpopoli

# Reference files
TRANSCRIPTS := $(REF_DIR)/human_transcripts.fa.gz
GENOME := $(REF_DIR)/human_genome.fa.gz
GENTROME := $(REF_DIR)/human_gentrome.fa.gz
DECOYS := $(REF_DIR)/decoys.txt
SALMON_INDEX := $(REF_DIR)/salmon_index
GTF := $(REF_DIR)/mappings.gtf

# Add R dependencies
R_DEPS := tximport readr GenomicFeatures AnnotationDbi jsonlite
SCRIPTS_DIR := $(SALMON_DIR)/scripts

# Group directory creation
create_base_dirs: $(SALMON_DIR) $(REF_DIR) $(FINISHED_DIR) $(ACCESSIONS_DIR)

create_project_dirs: $(PROJECT_DIR) $(SRA_DIR) $(SRA_DIR_TEMP) $(COUNTS_DIR)

# Setup directories and reference files
setup_salmon: create_base_dirs $(SALMON_INDEX) $(GTF) setup_r_deps $(SCRIPTS_DIR)/salmon_to_counts.R
	@echo "Setup complete. Directory structure created and reference files downloaded."

# Create directories
$(SALMON_DIR):
	mkdir -p $@

$(REF_DIR): | $(SALMON_DIR)
	mkdir -p $@

$(FINISHED_DIR):
	mkdir -p $@

$(ACCESSIONS_DIR):
	mkdir -p $@

# Download and prepare reference files
$(TRANSCRIPTS): | $(REF_DIR)
	curl https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_46/gencode.v46.transcripts.fa.gz -o $@

$(GENOME): | $(REF_DIR)
	curl https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_46/GRCh38.p14.genome.fa.gz -o $@

$(GTF).gz: | $(REF_DIR)
	curl https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_46/gencode.v46.annotation.gtf.gz -o $@

$(GTF): $(GTF).gz
	gzip -d $<

$(DECOYS): $(GENOME) | $(REF_DIR)
	gunzip -c $(GENOME) | grep "^>" | cut -d " " -f 1 | sed 's/>//g' > $@

$(GENTROME): $(TRANSCRIPTS) $(GENOME) | $(REF_DIR)
	cat $(TRANSCRIPTS) $(GENOME) > $@

$(SALMON_INDEX): $(GENTROME) $(DECOYS)
	salmon index -t $(GENTROME) -d $(DECOYS) --gencode -p $(THREADS) -i $@

# Quantification rules
quantify_salmon: setup_r_deps $(SCRIPTS_DIR)/salmon_to_counts.R create_project_dirs $(FINISHED_DIR)/all_counts_$(PROJECT).txt

# Make a project directory - now using scratch space
PROJECT_DIR := $(SCRATCH_DIR)/$(PROJECT)
SRA_DIR := $(PROJECT_DIR)/sra_out
SRA_DIR_TEMP := $(SRA_DIR)/temp
COUNTS_DIR := $(PROJECT_DIR)/salmon_gene_counts

$(PROJECT_DIR):
	mkdir -p $@

$(SRA_DIR): | $(PROJECT_DIR)
	mkdir -p $@

$(SRA_DIR_TEMP): | $(SRA_DIR)
	mkdir -p $@

$(COUNTS_DIR): | $(PROJECT_DIR)
	mkdir -p $@

# Preprocess SRR-only list if needed before copying
preprocess_srr_list:
	@echo "Checking if accession list contains only SRR identifiers..."
	@if [ -f "$(ACCESSIONS_DIR)/accession_list_$(PROJECT).txt" ]; then \
		if ! grep -q "|" $(ACCESSIONS_DIR)/accession_list_$(PROJECT).txt; then \
			echo "Detected SRR-only format. Converting to GSM-SRR format..."; \
			mv $(ACCESSIONS_DIR)/accession_list_$(PROJECT).txt $(ACCESSIONS_DIR)/srr_list_$(PROJECT).txt; \
			while read -r srr; do \
				echo "SRR_$$srr | $$srr" >> $(ACCESSIONS_DIR)/accession_list_$(PROJECT).txt; \
			done < $(ACCESSIONS_DIR)/srr_list_$(PROJECT).txt; \
			echo "Created synthetic GSM-SRR mapping. Original list saved as $(ACCESSIONS_DIR)/srr_list_$(PROJECT).txt"; \
		else \
			echo "Accession list already contains GSM-SRR mappings. No preprocessing needed."; \
		fi; \
	else \
		echo "ERROR: Accession list file not found at $(ACCESSIONS_DIR)/accession_list_$(PROJECT).txt"; \
		exit 1; \
	fi

# Copy and rename accession_list_PROJECT.txt into scratch sra_out as accession_list.txt
$(SRA_DIR)/accession_list.txt: $(ACCESSIONS_DIR)/accession_list_$(PROJECT).txt | $(SRA_DIR) $(ACCESSIONS_DIR)
	@echo "Checking accession list format..."
	@if ! grep -q "|" $<; then \
		echo "Detected SRR-only list. Converting to GSM-SRR format..."; \
		rm -f $(ACCESSIONS_DIR)/tmp_accession_list.txt; \
		while read -r srr; do \
			echo "SRR_$$srr | $$srr" >> $(ACCESSIONS_DIR)/tmp_accession_list.txt; \
		done < $<; \
		mv $(ACCESSIONS_DIR)/tmp_accession_list.txt $@; \
		echo "Created synthetic GSM-SRR mapping in scratch directory."; \
	else \
		echo "Copying and renaming accession list file..."; \
		cp $< $@; \
	fi

# Process SRA accessions and run Salmon quantification
$(FINISHED_DIR)/all_counts_$(PROJECT).txt: $(SRA_DIR)/accession_list.txt | $(COUNTS_DIR) $(FINISHED_DIR) $(SRA_DIR_TEMP)
	@echo "Processing GSM-SRR mapped accessions in batches of $(BATCH_SIZE)..."
	@echo "Using scratch directory: $(SCRATCH_DIR)"
	@# Create temporary directories
	@mkdir -p $(SRA_DIR)/fastq_temp
	@mkdir -p $(SRA_DIR)/mapping
	@mkdir -p $(SRA_DIR)/checkpoints
	@# Calculate total number of GSM samples and batches
	@total_lines=$$(wc -l < $(SRA_DIR)/accession_list.txt); \
	batch_count=$$(( ($${total_lines} + $(BATCH_SIZE) - 1) / $(BATCH_SIZE) )); \
	# Determine the starting batch number based on checkpoints \
	start_batch=1; \
	if [ -d "$(SRA_DIR)/checkpoints" ]; then \
		last_checkpoint=$$(ls -1 $(SRA_DIR)/checkpoints/batch_*.done 2>/dev/null | sort -V | tail -n 1 || echo ""); \
		if [ -n "$${last_checkpoint}" ]; then \
			last_batch=$$(echo $${last_checkpoint} | sed -E 's|.*/batch_([0-9]+)\.done$$|\1|'); \
			start_batch=$$(( $${last_batch} + 1 )); \
			echo "Resuming from batch $${start_batch} (previous batch $${last_batch} completed)"; \
		else \
			echo "No checkpoints found. Starting from batch 1"; \
		fi; \
	fi; \
	for batch_num in $$(seq $${start_batch} $${batch_count}); do \
		start_line=$$(( ($${batch_num} - 1) * $(BATCH_SIZE) + 1 )); \
		end_line=$$(( $${batch_num} * $(BATCH_SIZE) )); \
		if [ $${end_line} -gt $${total_lines} ]; then \
			end_line=$${total_lines}; \
		fi; \
		echo "Processing batch $${batch_num} of $${batch_count} (GSMs $${start_line} to $${end_line})"; \
		# Clean up any left over files from a previously interrupted batch \
		rm -f $(SRA_DIR)/fastq_temp/*.fastq $(SRA_DIR)/batch_$${batch_num}.txt $(SRA_DIR)/mapping/batch_$${batch_num}_srrs.txt $(SRA_DIR)/*.fastq; \
		# Extract current batch of GSM-SRR mappings \
		sed -n "$${start_line},$${end_line} p" $(SRA_DIR)/accession_list.txt > $(SRA_DIR)/batch_$${batch_num}.txt; \
		# Create list of all SRRs in this batch \
		cat $(SRA_DIR)/batch_$${batch_num}.txt | cut -d '|' -f 2 | tr ' ' '\n' | grep -v '^$$' > $(SRA_DIR)/mapping/batch_$${batch_num}_srrs.txt; \
		# Count SRRs in current batch and adjust thread allocation dynamically \
		srr_count=$$(wc -l < $(SRA_DIR)/mapping/batch_$${batch_num}_srrs.txt); \
		echo "Downloading $${srr_count} SRR files for batch $${batch_num}..."; \
		# Calculate threads per process, with minimum of 1 \
		threads_per_process=$$(( $(THREADS) / $${srr_count} )); \
		if [ $${threads_per_process} -lt 1]; then \
			threads_per_process=1; \
		fi; \
		echo "Allocating $${threads_per_process} threads per download process"; \
		# Download all SRRs in parallel \
		while read -r srr; do \
			echo "Starting download of $${srr}..."; \
			if [ "$(ENDTYPE)" = "single" ]; then \
				fasterq-dump $${srr} --threads $${threads_per_process} -O $(SRA_DIR)/fastq_temp -t $(SRA_DIR_TEMP) && echo "$${srr} download complete" & \
			else \
				fasterq-dump $${srr} --split-files --skip-technical --threads $${threads_per_process} -O $(SRA_DIR)/fastq_temp -t $(SRA_DIR_TEMP) && echo "$${srr} download complete" & \
			fi; \
		done < $(SRA_DIR)/mapping/batch_$${batch_num}_srrs.txt; \
		echo "Starting download monitoring..."; \
		start_time=$$(date +%s); \
		while jobs %% > /dev/null 2>&1; do \
			current=$$(date +%s); \
			elapsed=$$(( $${current} - $${start_time} )); \
			running=$$(jobs -p | wc -l); \
			echo "[$${elapsed} sec] Still waiting for $${running} fasterq-dump processes to complete..."; \
			sleep 30; \
		done; \
		echo "All downloads complete."; \
		echo "Concatenating files and quantifying for batch $${batch_num}..."; \
		# Process each GSM mapping \
		while IFS=' | ' read -r gsm srr_list || [ -n "$${gsm}" ]; do \
			echo "Processing GSM: $${gsm}"; \
			# Convert space-separated SRRs to array \
			srr_array=($${srr_list}); \
			# Determine if paired-end or single-end based on first SRR \
			is_paired=false; \
			if [ -f "$(SRA_DIR)/fastq_temp/$${srr_array[0]}_1.fastq" ] && [ -f "$(SRA_DIR)/fastq_temp/$${srr_array[0]}_2.fastq" ]; then \
				is_paired=true; \
				# Initialize concatenated files for paired-end \
				rm -f $(SRA_DIR)/$${gsm}_1.fastq $(SRA_DIR)/$${gsm}_2.fastq; \
				for srr in $${srr_array[@]}; do \
					if [ -f "$(SRA_DIR)/fastq_temp/$${srr}_1.fastq" ] && [ -f "$(SRA_DIR)/fastq_temp/$${srr}_2.fastq" ]; then \
						cat $(SRA_DIR)/fastq_temp/$${srr}_1.fastq >> $(SRA_DIR)/$${gsm}_1.fastq; \
						cat $(SRA_DIR)/fastq_temp/$${srr}_2.fastq >> $(SRA_DIR)/$${gsm}_2.fastq; \
					elif [ -f "$(SRA_DIR)/fastq_temp/$${srr}.fastq" ]; then \
						echo "Warning: SRR $${srr} is single-end but expected paired-end"; \
					fi; \
				done; \
			else \
				# Initialize concatenated file for single-end \
				rm -f $(SRA_DIR)/$${gsm}.fastq; \
				for srr in $${srr_array[@]}; do \
					if [ -f "$(SRA_DIR)/fastq_temp/$${srr}.fastq" ]; then \
						cat $(SRA_DIR)/fastq_temp/$${srr}.fastq >> $(SRA_DIR)/$${gsm}.fastq; \
					fi; \
				done; \
			fi; \
			# Run Salmon quantification on concatenated files
			if $${is_paired}; then \
				echo "Quantifying paired-end reads for $${gsm}"; \
				salmon quant -p $(THREADS) -i $(SALMON_INDEX) \
						--validateMappings --gcBias -l A \
						-1 $(SRA_DIR)/$${gsm}_1.fastq -2 $(SRA_DIR)/$${gsm}_2.fastq \
						-o $(COUNTS_DIR)/$${gsm}; \
			else \
				echo "Quantifying single-end reads for $${gsm}"; \
				salmon quant -p $(THREADS) -i $(SALMON_INDEX) \
						--validateMappings --gcBias -l A \
						-r $(SRA_DIR)/$${gsm}.fastq \
						-o $(COUNTS_DIR)/$${gsm}; \
			fi; \
		done < $(SRA_DIR)/batch_$${batch_num}.txt; \
		# Clean up batch files \
		echo "Cleaning up batch $${batch_num} files..."; \
		rm -f $(SRA_DIR)/fastq_temp/*.fastq $(SRA_DIR)/batch_$${batch_num}.txt $(SRA_DIR)/mapping/batch_$${batch_num}_srrs.txt $(SRA_DIR)/*.fastq; \
		# Mark this batch as completed \
		touch $(SRA_DIR)/checkpoints/batch_$${batch_num}.done; \
		echo "Batch $${batch_num} completed successfully"; \
	done
	@# Check if aggregation has been completed
	@if [ -f "$(SRA_DIR)/checkpoints/aggregation.done" ]; then \
		echo "Aggregation already completed. Using existing count matrix."; \
		if [ ! -f "$@" ]; then \
			echo "ERROR: Checkpoint indicates aggregation is complete but output file is missing."; \
			rm $(SRA_DIR)/checkpoints/aggregation.done; \
			echo "Removed invalid checkpoint. Please rerun the pipeline."; \
			exit 1; \
		fi; \
	else \
		echo "Aggregating gene counts using tximport..."; \
		# Use tximport to get gene-level counts from transcript-level estimates \
		Rscript $(SCRIPTS_DIR)/salmon_to_counts.R \
			$(COUNTS_DIR) \
			$(GTF) \
			$@ \
			$(PROJECT); \
		touch $(SRA_DIR)/checkpoints/aggregation.done; \
	fi
	@# Clean up only if aggregation is complete
	@if [ -f "$(SRA_DIR)/checkpoints/aggregation.done" ]; then \
		echo "Cleaning up scratch directory..."; \
		rm -rf $(PROJECT_DIR); \
		echo "Quantification complete. Results available in $(FINISHED_DIR)/all_counts_$(PROJECT).txt"; \
	else \
		echo "WARNING: Processing incomplete. Temporary files retained for next run."; \
	fi

# Add a new target to force reset checkpoints
reset_checkpoints:
	@echo "Resetting all checkpoints for project $(PROJECT)..."
	@rm -rf $(SCRATCH_DIR)/$(PROJECT)/sra_out/checkpoints
	@echo "Checkpoints reset. Next run will start from the beginning."

# Clean up
clean_salmon:
	rm -rf $(SALMON_DIR)
	# Also clean any leftover scratch directories if possible
	rm -rf $(SCRATCH_DIR)/*

# Help target
help:
	@echo ""
	@echo "RNA-Seq Analysis Pipeline Makefile"
	@echo "Usage:"
	@echo "  make setup_salmon THREADS=<num_threads>		- Set up directories and download reference files"
	@echo "  make quantify_salmon ENDTYPE=<single|paired> THREADS=<num_threads> BATCH_SIZE=<num> PROJECT=<your_project>		- Run Salmon quantification"
	@echo "  make preprocess_srr_list PROJECT=<your_project>	- Preprocess SRR-only list into GSM-SRR format"
	@echo "  make clean_salmon		- Remove all generated files"
	@echo "  make help		- Show this help message"
	@echo ""
	@echo "Input Files:"
	@echo "  accession_lists/accession_list_<PROJECT>.txt - Either:"
	@echo "    * GSM-SRR mappings in format: 'GSM123456 | SRR123456 SRR123457'"
	@echo "    * SRR-only list with one SRR ID per line (will be auto-converted)"
	@echo ""
	@echo "Variables:"
	@echo "  THREADS			- Number of threads to use (default: 4)"
	@echo "  ENDTYPE			- Type of sequencing reads: 'single' or 'paired' (default: paired)"
	@echo "  BATCH_SIZE			- Number of accessions to process simultaneously (default: 6)"
	@echo "  PROJECT			- Name of the project (default: current date)"
	@echo ""
	@echo "Scratch space at $(SCRATCH_DIR) is used for temporary files"
	@echo ""

# Add a step to ensure R packages are installed
setup_r_deps:
	@echo "Checking R dependencies..."
	@Rscript -e 'missing <- setdiff(c("$(R_DEPS)"), installed.packages()[,"Package"]); if(length(missing) > 0) { install.packages(missing, repos="https://cloud.r-project.org") }'
	@Rscript -e 'if(!"tximport" %in% installed.packages()[,"Package"]) { if(!"BiocManager" %in% installed.packages()[,"Package"]) { install.packages("BiocManager", repos="https://cloud.r-project.org") }; BiocManager::install("tximport") }'
	@echo "R dependencies check complete."

# Create scripts directory if it doesn't exist
$(SCRIPTS_DIR):
	mkdir -p $@

# Ensure salmon_to_counts.R script exists
$(SCRIPTS_DIR)/salmon_to_counts.R: | $(SCRIPTS_DIR)
	@if [ ! -f "$@" ]; then \
    	echo "Creating tximport R script..."; \
    	echo '#!/usr/bin/env Rscript' > $@; \
    	echo '' >> $@; \
    	echo '# Load required libraries' >> $@; \
        echo 'suppressPackageStartupMessages({' >> $@; \
        echo '  library(tximport)' >> $@; \
        echo '  library(readr)' >> $@; \
        echo '  library(GenomicFeatures)' >> $@; \
        echo '})' >> $@; \
        echo '' >> $@; \
        echo '# Get command line arguments' >> $@; \
        echo 'args <- commandArgs(trailingOnly = TRUE)' >> $@; \
        echo 'if (length(args) < 4) {' >> $@; \
        echo '  stop("Usage: Rscript salmon_to_counts.R <counts_dir> <gtf_file> <output_file> <project_name>")' >> $@; \
        echo '}' >> $@; \
        echo '' >> $@; \
        echo 'counts_dir <- args[1]' >> $@; \
        echo 'gtf_file <- args[2]' >> $@; \
        echo 'output_file <- args[3]' >> $@; \
        echo 'project_name <- args[4]' >> $@; \
        echo '' >> $@; \
        echo '# Print diagnostic information' >> $@; \
        echo 'message("Processing project: ", project_name)' >> $@; \
        echo 'message("Processing counts directory: ", counts_dir)' >> $@; \
        echo 'message("Using GTF file: ", gtf_file)' >> $@; \
        echo 'message("Output will be written to: ", output_file)' >> $@; \
        echo '' >> $@; \
        echo '# Create transcript-to-gene mapping from GTF' >> $@; \
        echo 'message("Creating transcript-to-gene mapping from GTF...")' >> $@; \
        echo 'txdb <- makeTxDbFromGFF(gtf_file)' >> $@; \
        echo 'k <- keys(txdb, keytype = "TXNAME")' >> $@; \
        echo 'tx2gene <- AnnotationDbi::select(txdb, k, "GENEID", "TXNAME")' >> $@; \
        echo '' >> $@; \
        echo '# Get all sample folders (excluding non-sample directories)' >> $@; \
        echo 'message("Scanning for sample directories...")' >> $@; \
        echo 'samples <- list.dirs(counts_dir, full.names = FALSE, recursive = FALSE)' >> $@; \
        echo 'samples <- samples[samples != "" & !grepl("genes\\.txt", samples)]' >> $@; \
        echo 'message(paste("Found", length(samples), "sample directories"))' >> $@; \
        echo '' >> $@; \
        echo '# Create file paths to quant.sf files' >> $@; \
        echo 'files <- file.path(counts_dir, samples, "quant.sf")' >> $@; \
        echo 'names(files) <- samples' >> $@; \
        echo '' >> $@; \
        echo '# Check if all files exist' >> $@; \
        echo 'missing_files <- files[!file.exists(files)]' >> $@; \
        echo 'if (length(missing_files) > 0) {' >> $@; \
        echo '  warning("The following quant files are missing: ", paste(missing_files, collapse=", "))' >> $@; \
        echo '  files <- files[file.exists(files)]' >> $@; \
        echo '}' >> $@; \
        echo '' >> $@; \
        echo '# Run tximport to get gene-level counts' >> $@; \
        echo 'message("Running tximport for gene-level summarization...")' >> $@; \
        echo 'txi <- tximport(files, type = "salmon", tx2gene = tx2gene, ignoreAfterBar = TRUE,' >> $@; \
        echo '                countsFromAbundance = "no")  # Use "no" for raw estimated counts' >> $@; \
        echo '' >> $@; \
        echo '# Extract different count types' >> $@; \
        echo 'message("Extracting count matrices...")' >> $@; \
        echo 'raw_counts <- round(txi$$counts)  # Raw estimated counts, rounded to integers' >> $@; \
        echo 'tpm <- txi$$abundance  # TPM values' >> $@; \
        echo '' >> $@; \
        echo '# Write output files' >> $@; \
        echo 'message("Writing count matrices...")' >> $@; \
        echo '# Raw counts' >> $@; \
        echo 'write.table(raw_counts, file = output_file,' >> $@; \
        echo '            sep = "\t", quote = FALSE, col.names = NA)' >> $@; \
        echo '' >> $@; \
        echo '# TPM values - save alongside raw counts' >> $@; \
        echo 'tpm_file <- file.path(dirname(output_file), paste0("tpm_counts_", basename(output_file)))' >> $@; \
        echo 'write.table(tpm, file = tpm_file,' >> $@; \
        echo '            sep = "\t", quote = FALSE, col.names = NA)' >> $@; \
        echo '' >> $@; \
        echo 'message("Gene-level counts successfully written to ", output_file)' >> $@; \
        echo 'message("TPM values written to ", tpm_file)' >> $@; \
        chmod +x $@; \
    fi
